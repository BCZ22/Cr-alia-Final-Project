# PR 9: Render worker & export

## üéØ Objectif

Int√©grer un syst√®me complet de rendu vid√©o bas√© sur FFmpeg avec support GPU, scalable et monitor√© pour assurer un rendu professionnel, rapide et stable des projets vid√©o.

## ‚ú® Fonctionnalit√©s Impl√©ment√©es

### A. Workers de Rendu avec FFmpeg et GPU Support

**Workers Conteneuris√©s:**
- ‚úÖ **Docker containers** : Workers FFmpeg isol√©s et scalables
- ‚úÖ **GPU hardware acceleration** : NVIDIA NVENC, Intel QuickSync, AMD VCE
- ‚úÖ **D√©tection automatique** : GPU disponible et capacit√©s
- ‚úÖ **Fallback CPU** : Rendu logiciel si GPU indisponible

**Pipeline de Rendu:**
- ‚úÖ **Ingestion timeline JSON** : Conversion des donn√©es de projet
- ‚úÖ **Application des effets** : Effets, transitions, audio, keyframes
- ‚úÖ **Encodage final** : Multi-formats avec optimisations
- ‚úÖ **Logs d√©taill√©s** : FFmpeg logs + worker logs
- ‚úÖ **Syst√®me de retry** : Reprise en cas d'√©chec

### B. Pipeline de Rendu Scalable et Reproductible

**Conversion Timeline:**
- ‚úÖ **Instructions FFmpeg d√©terministes** : M√™me projet = m√™me rendu
- ‚úÖ **Reproductibilit√© garantie** : R√©sultats identiques √† chaque export
- ‚úÖ **Rendus multiples** : Diff√©rentes r√©solutions/bitrates par projet
- ‚úÖ **Versioning des pipelines** : Compatibilit√© ascendante

**Optimisations:**
- ‚úÖ **Cache intelligent** : R√©utilisation des assets trait√©s
- ‚úÖ **Parall√©lisation** : Traitement simultan√© de plusieurs jobs
- ‚úÖ **Load balancing** : R√©partition intelligente de la charge
- ‚úÖ **Resource management** : Gestion optimis√©e des ressources

### C. Export Multi-formats avec Optimisations

**Formats Support√©s:**
- ‚úÖ **MP4** : H.264, H.265/HEVC avec optimisations
- ‚úÖ **MOV** : ProRes pour haute qualit√© professionnelle
- ‚úÖ **WebM** : VP9/AV1 pour web et streaming
- ‚úÖ **GIF** : Boucles courtes optimis√©es

**Optimisations Int√©gr√©es:**
- ‚úÖ **Bitrate adaptatif** : Optimisation qualit√©/taille
- ‚úÖ **Presets r√©seaux sociaux** : TikTok, YouTube Shorts, Instagram Reels
- ‚úÖ **Optimisation audio** : AAC, Opus, WAV lossless
- ‚úÖ **M√©tadonn√©es** : Informations de projet int√©gr√©es

### D. File d'Attente avec Suivi Temps R√©el

**Queue System:**
- ‚úÖ **Redis/BullMQ** : Queue robuste et performante
- ‚úÖ **Gestion compl√®te des jobs** : pending, processing, completed, failed
- ‚úÖ **Notifications temps r√©el** : WebSocket/GraphQL Subscriptions
- ‚úÖ **Estimation temps restant** : Affichage utilisateur
- ‚úÖ **Logs consultables** : Debug par utilisateur

**Monitoring:**
- ‚úÖ **Statut en temps r√©el** : Progression d√©taill√©e
- ‚úÖ **Historique des jobs** : Suivi des rendus pr√©c√©dents
- ‚úÖ **M√©triques de performance** : Temps, d√©bit, erreurs
- ‚úÖ **Alertes automatiques** : Notifications d'√©tat

### E. Auto-scaling Horizontal (Kubernetes)

**D√©ploiement Scalable:**
- ‚úÖ **Kubernetes pods** : Workers scalables automatiquement
- ‚úÖ **Auto-scaling** : CPU/GPU et nombre de jobs en attente
- ‚úÖ **Load balancing** : R√©partition intelligente entre workers
- ‚úÖ **Tol√©rance aux pannes** : Job relanc√© ailleurs si worker crash

**Orchestration:**
- ‚úÖ **HPA (Horizontal Pod Autoscaler)** : Scaling automatique
- ‚úÖ **Resource quotas** : Limites par namespace
- ‚úÖ **Health checks** : Monitoring de sant√© des workers
- ‚úÖ **Graceful shutdown** : Arr√™t propre des workers

### F. Monitoring et M√©triques de Performance

**Int√©gration Prometheus + Grafana:**
- ‚úÖ **Nombre de jobs par √©tat** : pending, processing, completed, failed
- ‚úÖ **Temps moyen de rendu** : M√©triques de performance
- ‚úÖ **Utilisation CPU/GPU** : Monitoring des ressources
- ‚úÖ **Erreurs FFmpeg** : Tracking des √©checs
- ‚úÖ **Alerting** : Slack/Email en cas de surcharge

**Dashboards:**
- ‚úÖ **Vue d'ensemble** : √âtat global du syst√®me
- ‚úÖ **D√©tails par worker** : Performance individuelle
- ‚úÖ **M√©triques utilisateur** : Statistiques par utilisateur
- ‚úÖ **Alertes** : Notifications en temps r√©el

## üèóÔ∏è Architecture

### Render Store (Zustand)

```typescript
interface RenderStore {
  // Jobs and queue
  jobs: RenderJob[];
  queue: RenderQueue;
  selectedJobId?: string;
  
  // Settings
  defaultSettings: RenderSettings;
  currentSettings: RenderSettings;
  
  // Metrics and monitoring
  metrics: RenderMetrics;
  workers: WorkerInfo[];
  
  // UI state
  showRenderPanel: boolean;
  showQueuePanel: boolean;
  showMetricsPanel: boolean;
  autoRefresh: boolean;
  refreshInterval: number;
  
  // Real-time updates
  isConnected: boolean;
  lastUpdate: string;
}
```

### Render Service

```typescript
class RenderService {
  private renderQueue: Queue;
  private worker: Worker;

  async createRenderJob(userId: string, projectId: string, settings: RenderSettings): Promise<RenderJob>;
  async getRenderJob(jobId: string, userId: string): Promise<RenderJob>;
  async cancelRenderJob(jobId: string, userId: string): Promise<void>;
  async retryRenderJob(jobId: string, userId: string): Promise<void>;
  async deleteRenderJob(jobId: string, userId: string): Promise<void>;
  async getQueueStatus(): Promise<QueueStatus>;
  async getMetrics(): Promise<RenderMetrics>;
  async getWorkers(): Promise<WorkerInfo[]>;
}
```

### FFmpeg Worker

```typescript
class RenderWorker {
  private gpuAvailable: boolean;
  private gpuType: string;
  private capabilities: string[];

  async processRenderJob(job: Job<RenderJobData>): Promise<RenderResult>;
  private generateFFmpegCommand(timelineData: any, settings: any): string[];
  private executeFFmpeg(command: string[], jobId: string): Promise<RenderResult>;
  private detectGPU(): Promise<void>;
  private cleanup(tempDir: string): Promise<void>;
}
```

### API Endpoints

```typescript
// Render job management
POST /api/video-editor/projects/[id]/render
GET /api/video-editor/projects/[id]/render
GET /api/video-editor/renders
GET /api/video-editor/renders/[id]
DELETE /api/video-editor/renders/[id]

// Job control
POST /api/video-editor/renders/[id]/cancel
POST /api/video-editor/renders/[id]/retry
GET /api/video-editor/renders/[id]/download

// Monitoring
GET /api/video-editor/renders/queue
GET /api/video-editor/renders/metrics
GET /api/video-editor/renders/workers
```

## üé® Design & UX

### Interface Professionnelle
- **Panneau de rendu int√©gr√©** : Onglets Param√®tres, File d'attente, M√©triques
- **Configuration avanc√©e** : Presets, formats, codecs, qualit√©
- **Suivi temps r√©el** : Progression, statut, logs
- **Monitoring complet** : Workers, ressources, performance

### Render Panel
```typescript
const renderPanel = {
  settings: 'Configuration des param√®tres de rendu',
  queue: 'File d\'attente et statut des jobs',
  metrics: 'M√©triques de performance et monitoring',
  presets: 'Presets pr√©d√©finis par usage',
  realTime: 'Mises √† jour en temps r√©el'
};
```

### Presets d'Export
```typescript
const presets = {
  standard: 'MP4 H.264 1080p - Usage g√©n√©ral',
  social: 'MP4 H.264 1080p 9:16 - R√©seaux sociaux',
  high_quality: 'MOV ProRes 4K - Haute qualit√©',
  web: 'WebM VP9 720p - Streaming web',
  archive: 'MP4 H.265 1080p - Archivage'
};
```

## üîß Fonctionnalit√©s Techniques

### FFmpeg Command Generation

```typescript
private generateFFmpegCommand(timelineData: any, settings: any): string[] {
  const command: string[] = ['ffmpeg', '-y'];
  
  // Input files
  const inputFiles = this.getInputFiles(timelineData);
  for (const inputFile of inputFiles) {
    command.push('-i', inputFile);
  }
  
  // Video filters
  const videoFilters = this.generateVideoFilters(timelineData, settings);
  if (videoFilters.length > 0) {
    command.push('-filter_complex', videoFilters.join(';'));
  }
  
  // Video codec and settings
  if (settings.gpuAcceleration && this.gpuAvailable) {
    command.push('-c:v', this.getGPUCodec(settings.codec));
    command.push('-preset', 'fast');
  } else {
    command.push('-c:v', this.getCPUCodec(settings.codec));
    command.push('-preset', 'medium');
  }
  
  // Quality settings
  if (settings.crf) {
    command.push('-crf', settings.crf.toString());
  } else if (settings.bitrate) {
    command.push('-b:v', `${settings.bitrate}k`);
  }
  
  return command;
}
```

### GPU Detection

```typescript
private async detectGPU() {
  try {
    // Check for NVIDIA GPU
    const nvidiaCheck = spawn('nvidia-smi', ['--query-gpu=name', '--format=csv,noheader,nounits']);
    nvidiaCheck.on('close', (code) => {
      if (code === 0) {
        this.gpuAvailable = true;
        this.gpuType = 'nvidia';
        this.capabilities.push('nvenc', 'nvenc_h264', 'nvenc_hevc');
      }
    });
    
    // Check for Intel QuickSync
    const intelCheck = spawn('vainfo', []);
    intelCheck.on('close', (code) => {
      if (code === 0 && !this.gpuAvailable) {
        this.gpuAvailable = true;
        this.gpuType = 'intel';
        this.capabilities.push('qsv', 'h264_qsv', 'hevc_qsv');
      }
    });
    
    // Check for AMD VCE
    const amdCheck = spawn('vainfo', []);
    amdCheck.on('close', (code) => {
      if (code === 0 && !this.gpuAvailable) {
        this.gpuAvailable = true;
        this.gpuType = 'amd';
        this.capabilities.push('amf', 'h264_amf', 'hevc_amf');
      }
    });
  } catch (error) {
    console.log('GPU detection failed, using CPU only');
  }
}
```

### Queue Management

```typescript
class RenderService {
  private initializeQueue() {
    this.renderQueue = new Queue('render-queue', {
      connection: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        password: process.env.REDIS_PASSWORD
      },
      defaultJobOptions: {
        removeOnComplete: 100,
        removeOnFail: 50,
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000
        }
      }
    });
  }
  
  private getJobPriority(preset: string): number {
    switch (preset) {
      case 'high_quality': return 1; // Highest priority
      case 'standard': return 5;
      case 'social': return 3;
      case 'web': return 7;
      case 'archive': return 9; // Lowest priority
      default: return 5;
    }
  }
}
```

### WebSocket Integration

```typescript
// Real-time updates
connectWebSocket: () => {
  const ws = new WebSocket(process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001/ws');
  
  ws.onopen = () => {
    set({ isConnected: true });
    console.log('WebSocket connected');
  };

  ws.onmessage = (event) => {
    const message = JSON.parse(event.data);
    get().handleWebSocketMessage(message);
  };

  ws.onclose = () => {
    set({ isConnected: false });
    console.log('WebSocket disconnected');
    // Reconnect after 5 seconds
    setTimeout(() => get().connectWebSocket(), 5000);
  };
}
```

## üì± Responsive Design

### Adaptations par √âcran
- **Desktop** : Panneau complet avec tous les contr√¥les
- **Tablet** : Interface simplifi√©e avec contr√¥les essentiels
- **Mobile** : Version tactile avec gestes optimis√©s

### Optimisations Tactiles
- **Configuration** : Sliders et s√©lecteurs adapt√©s au touch
- **Monitoring** : Graphiques et m√©triques lisibles
- **Navigation** : Swipe entre onglets, tap pour actions

## üß™ Tests

### Tests Unitaires
```typescript
describe('Render Store', () => {
  it('devrait cr√©er un job de rendu', async () => {
    // Test cr√©ation job
  });
  
  it('devrait g√©rer la file d\'attente', async () => {
    // Test queue management
  });
  
  it('devrait appliquer des presets', () => {
    // Test presets
  });
});
```

### Tests E2E
```typescript
test('sc√©nario complet de rendu et export', async ({ page }) => {
  // 1. Configurer les param√®tres de rendu
  // 2. Lancer un rendu
  // 3. Suivre la progression
  // 4. T√©l√©charger le fichier final
  // 5. V√©rifier la qualit√©
});
```

### Tests de Performance
- **Rendu simultan√©** : 50 jobs en parall√®le
- **Auto-scaling** : Mont√©e en charge automatique
- **Monitoring** : M√©triques Prometheus
- **R√©silience** : Gestion des pannes

## üöÄ Performance

### Optimisations
- **GPU acceleration** : Rendu 3-5x plus rapide
- **Parall√©lisation** : Traitement simultan√©
- **Cache intelligent** : R√©utilisation des assets
- **Load balancing** : R√©partition optimale

### M√©triques Cibles
- **Temps de rendu** : < 2x temps r√©el pour 1080p
- **Throughput** : 100+ jobs/heure
- **Latence** : < 1s pour d√©marrage job
- **Disponibilit√©** : 99.9% uptime

## üîí S√©curit√©

### Isolation
```typescript
const validateRenderJob = (job: RenderJob, userId: string) => {
  // V√©rifier les permissions
  if (job.userId !== userId) {
    throw new Error('No permission');
  }
  
  // Valider les param√®tres
  if (job.bitrate && (job.bitrate < 1000 || job.bitrate > 50000)) {
    throw new Error('Invalid bitrate');
  }
  
  // Limiter les ressources
  if (job.quality === '4K' && !userHasPremiumAccess(userId)) {
    throw new Error('4K requires premium access');
  }
};
```

### Gestion d'Erreurs
- **Timeout** : Limite de temps par job
- **Resource limits** : CPU, m√©moire, disque
- **Cleanup** : Suppression automatique des fichiers temporaires
- **Retry logic** : Nouvelle tentative en cas d'√©chec

## üìä Monitoring

### M√©triques d'Usage
- **Jobs populaires** : Formats et qualit√©s les plus demand√©s
- **Performance** : Temps de rendu par format
- **Ressources** : Utilisation CPU/GPU
- **Erreurs** : Types d'√©checs les plus fr√©quents

### Analytics
- **Performance** : Temps de rendu, d√©bit, latence
- **UX** : Abandons, retry rates, satisfaction
- **Co√ªts** : Ressources utilis√©es, co√ªt par job

## üéØ Crit√®res d'Acceptation

‚úÖ **Workers FFmpeg** : GPU support avec fallback CPU
‚úÖ **Pipeline reproductible** : M√™me r√©sultat √† chaque export
‚úÖ **Export multi-formats** : MP4, MOV, WebM, GIF optimis√©s
‚úÖ **File d'attente** : Suivi temps r√©el avec notifications
‚úÖ **Auto-scaling** : Kubernetes avec HPA
‚úÖ **Monitoring** : Prometheus + Grafana avec alertes
‚úÖ **Tests complets** : Unitaires, E2E, performance
‚úÖ **Documentation** : Guide utilisateur et d√©veloppeur

## üîÆ Prochaines √âtapes

- **PR 10** : Collaboration en temps r√©el
- **PR 11** : AI features et automation
- **PR 12** : Administration et mon√©tisation

---

**Status** : ‚úÖ **TERMIN√â** - Syst√®me complet de rendu vid√©o avec GPU acceleration et monitoring
